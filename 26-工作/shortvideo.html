<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>滑动视频</title>
</head>
<body>
	
</body>
<script>

/**
     * 滑动处理
     */
    function Touch() {
        this.init();
    }
    Touch.fn = Touch.prototype;
    Touch.fn.init = function (params) {
        var self = this;
        dataStore.lastY = dataStore.translateY;//记录当前位移
        self.startY = 0;
        self.moveY = 0;
        // self.lock = 0;//如果在回调或上升阶段不允许滑动.
        self.bodyHeight = window.innerHeight;
        self.resetLimitY();
        self.isIOS = /ip(?:hone|ad|od)/.test(navigator.userAgent.toLowerCase());
        ['touchstart','touchmove','touchend'].forEach(function (str) {
            document.addEventListener(str,self[str].bind(self));
        });
    }
    Touch.fn.touchstart = function(e){
        var self = this;
        if(dataStore.lock) return;
        self.startY = e.touches[0].pageY;
        self.start = Date.now();//标识滑动起始时间，也用于标识滑动start
    }
    Touch.fn.move = function (y) {
        dataStore.translateY = y;
    }
    Touch.fn.touchmove = function(e){
        var self = this;
        if(dataStore.lock||!self.start) return;//锁定了，或者没有start，主要是手势一直滑动情况，已经加速度划走了，手势需要松开再重新开始
        self.moveY = e.touches[0].pageY - self.startY;
        self.move(self.moveY+ dataStore.lastY);   
        self.detect();     
    }
    Touch.fn.detect = function(isEnd){
        var self = this;
        // console.log(self.moveY+"  "+(Date.now()-self.start));
        var a = Math.abs(self.moveY)/(Date.now()-self.start)>=0.5;
        if(isEnd){
            if(a){
                self.limitY = 0;
            }
            self.movend();
            return;
        }
        if(self.isIOS&&a){//IOS，可以在touchmove时直接滑动，体验流畅。
            self.limitY = 0;
            self.movend();
        }
        
    }
    Touch.fn.resetLimitY = function () {
        this.limitY = this.bodyHeight/3;//位移多少才下滑
    }
    Touch.fn.touchend = function (e) {
        var self = this;
        if(dataStore.lock||self.moveY==0||!self.start) return;
        self.detect(1);     
    }
    Touch.fn.movend = function () {
        // if(dataStore.lock) return;
        // dataStore.lock = 1;
        var self = this;
        /***
         * 最后上下位移小于最小值则还原为上一次位移，
         * 否则，那么就需要上移或下移一个body宽度，上移则translate加，下移在减去一个body
         * 这里是计算出了应该位移高度。
         */
        var transformY = Math.abs(self.moveY)<self.limitY?dataStore.lastY:dataStore.lastY+self.bodyHeight*(self.moveY>0?1:-1);
         
        /***
         * 还需计算最大下滑高度和最大上滑高度
         */
        var listUL = document.querySelector(".quan_vcd_list");
        var listHeight = listUL.getBoundingClientRect().height;
        
        //如果是最后一个li，则不能下滑，
        var maxBottom = (listHeight - self.bodyHeight)*-1;
        var lastComputeY = transformY>0?0:transformY<maxBottom?maxBottom:transformY;
        //停止滑动之后，自动滚动距离，transition
        listUL.classList.add('trans');
        
        if(lastComputeY<=0){
            var d = lastComputeY-dataStore.lastY;
            d&&events.trigger("touch_move",d,(-lastComputeY/self.bodyHeight));
        }
        self.start = 0;
        var raf = window.requestAnimationFrame|| window.webkitRequestAnimationFrame;
        raf(function () {
            self.move(lastComputeY);
            self.moveY = 0;
            dataStore.lastY = lastComputeY;//记录确定的位置
            if(listHeight+dataStore.lastY<=self.bodyHeight){
                events.trigger("turnPage");
            }
            setTimeout(function () {
                listUL.classList.remove("trans");
                dataStore.lock = 0;
                self.resetLimitY();
            },500);
        });
    }

</script>
</html>